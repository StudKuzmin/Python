Инструменты функционального программирования в Python

При map вычисление квадратов чисел происходит на лету
map хранит 1 элемент(не требует много памяти) в отличие от списочного выражения

типы итерируемых объектов
1) Итераторы
2) Классы с определённым интерфейсом(коллекции, range и тд)

Итератор - объект, который позволяет поочередно перебирать элементы.

a = [1, 2]
my_iter = iter(a)
print(next(my_iter)) # выведет 1
print(next(my_iter)) # выведет 2
print(next(my_iter)) # выведет stop_iter

В памяти хранится только текущее значение интератора

Создание итераторов:
1) Написать класс реализующий метод __iter__() и __next__()
2) Функция-генератор
3) Генераторное выражение

Генератор - специальный класс функций, который позволяет легко создавать свои итераторы
Генератор вместо return использует yield
def my_generator():
	yield 1
	yield 2
	yield 3
my_gen = my_generator()
my_gen = (i ** 2 for i in range(10))

функции высшего порядка - функции, которые принимают другие функции или возвращают их

words = ['мир', 'и', 'война']
print(sorted(words, key=lambda word: len(word)))
# Выведет 'и', 'мир', 'война'

print([5, 'b'] > [6, 'a']) # Сравнивает списки по 1-му элементу



######################## all, any, enumerate ####################

all - функция проверяет, что все элементы переданного ей итерируемого объекта возвращают True
any - хотя бы 1 True

print(all([1, 2, 3, 4, 5, 6, 7, 8, 9]))
# True - так как все элементы ненулевые

print(any(set(), [], {}, 0, True))
# True - т.к. есть True среди всех элементов

data = [1, 2, 3, 4, 5]
print(all(x % 2 == 0 for x in date))

enumerate()

########################### zip ################################

zip() - принимает несколько выражений и объединяет их в кортежи

functools - библиотека питон для работы с функциями высшего порядка

reduce() - обновляет некоторую величину шаг за шагом, начиная с некоторого начального значения

def print_uppercase(*args):
	...

print = print_uppercase